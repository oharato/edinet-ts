#!/usr/bin/env node
/**
 * Auto-generate type documentation from TypeScript source files
 * Extracts interface definitions and JSDoc comments using ts-morph
 */

const { Project } = require("ts-morph");
const path = require("path");
const fs = require("fs");

/**
 * Extract field info from an interface declaration
 */
function extractInterfaceInfo(interfaceDecl) {
    const fields = [];

    // Extract interface description
    const interfaceJsDocs = interfaceDecl.getJsDocs();
    let description = interfaceDecl.getName();
    if (interfaceJsDocs.length > 0) {
        description = interfaceJsDocs[0].getDescription().trim();
        // Clean up newlines
        description = description
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .join(' ');
    }

    interfaceDecl.getProperties().forEach(prop => {
        const key = prop.getName();
        const typeNode = prop.getTypeNode();
        // Get the text of the type node, or fallback to the type object's text
        let type = typeNode ? typeNode.getText() : prop.getType().getText();

        // Check if optional
        const isOptional = prop.hasQuestionToken();
        if (isOptional) {
            type += " (optional)";
        }

        // Get JSDoc description
        const jsDocs = prop.getJsDocs();
        let japaneseLabel = "";
        if (jsDocs.length > 0) {
            japaneseLabel = jsDocs[0].getDescription().trim();

            // Clean up newlines in description
            japaneseLabel = japaneseLabel
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .join(' ');
        }

        fields.push({ key, japaneseLabel, type });
    });

    return {
        name: interfaceDecl.getName(),
        description,
        fields
    };
}

/**
 * Extract document type definition from an interface
 */
function extractDocumentTypeInfo(interfaceDecl) {
    const jsDocs = interfaceDecl.getJsDocs();
    if (jsDocs.length === 0) return null;

    const description = jsDocs[0].getDescription().trim().split('\n').join(' ');

    const tags = jsDocs[0].getTags();
    let documentType = "";
    let japaneseLabel = "";

    for (const tag of tags) {
        const tagName = tag.getTagName();
        const tagText = tag.getCommentText ? tag.getCommentText() : ""; // handle different ts-morph versions or fallback

        if (tagName === "documentType") {
            documentType = tagText ? tagText.trim() : "";
        } else if (tagName === "japaneseLabel") {
            japaneseLabel = tagText ? tagText.trim() : "";
        }
    }

    if (!documentType || !japaneseLabel) {
        return null;
    }

    const responseIncludes = [];
    interfaceDecl.getProperties().forEach(prop => {
        const typeName = prop.getTypeNode() ? prop.getTypeNode().getText() : prop.getType().getText();
        // Map type name directly to DOC constant
        // Assumes naming convention: TypeName -> TYPE_NAME_DOC
        const docConstant = typeName.replace(/([A-Z])/g, '_$1').toUpperCase().replace(/^_/, '') + "_DOC";
        responseIncludes.push(docConstant);
    });

    return {
        documentType,
        japaneseLabel,
        description,
        responseIncludes
    };
}

/**
 * Generate TypeScript code for type documentation
 */
function generateTypeDocCode(interfaces, docTypes) {
    let code = `/**
 * Auto-generated type documentation
 * Generated using ts-morph
 * DO NOT EDIT THIS FILE MANUALLY - Run 'npm run generate-type-docs' to regenerate
 */

export interface FieldInfo {
    key: string;
    japaneseLabel: string;
    type: string;
}

export interface TypeDocumentation {
    typeName: string;
    description: string;
    fields: FieldInfo[];
}

`;

    // Generate constants for each interface
    for (const iface of interfaces) {
        const constName = iface.name.replace(/([A-Z])/g, '_$1').toUpperCase().replace(/^_/, '');

        code += `export const ${constName}_DOC: TypeDocumentation = {\n`;
        code += `    typeName: "${iface.name}",\n`;
        code += `    description: "${iface.description}",\n`;
        code += `    fields: [\n`;

        for (const field of iface.fields) {
            // Escape special characters for TypeScript string literal
            const escapedLabel = field.japaneseLabel
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
            // Escape backticks in type string if any (though unlikely for simple types)
            const escapedType = field.type
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"');

            code += `        { key: "${field.key}", japaneseLabel: "${escapedLabel}", type: "${escapedType}" },\n`;
        }

        code += `    ]\n`;
        code += `};\n\n`;
    }

    // Add document type responses
    code += `export interface DocumentTypeResponse {
    documentType: string;
    japaneseLabel: string;
    description: string;
    responseIncludes: TypeDocumentation[];
}

export const DOCUMENT_TYPE_RESPONSES: DocumentTypeResponse[] = [\n`;

    for (const dt of docTypes) {
        code += `    {\n`;
        code += `        documentType: "${dt.documentType}",\n`;
        code += `        japaneseLabel: "${dt.japaneseLabel}",\n`;
        code += `        description: "${dt.description}",\n`;
        code += `        responseIncludes: [${dt.responseIncludes.join(', ')}]\n`;
        code += `    },\n`;
    }

    code += `];\n\n`;

    code += `export function generateTypeMarkdown(doc: TypeDocumentation): string {
    let md = \`### \${doc.typeName}\\n\\n\`;
    md += \`\${doc.description}\\n\\n\`;
    md += \`| キー | 日本語名 | 型 |\\n\`;
    md += \`| --- | --- | --- |\\n\`;

    for (const field of doc.fields) {
        md += \`| \\\`\${field.key}\\\` | \${field.japaneseLabel} | \\\`\${field.type}\\\` |\\n\`;
    }

    return md;
}

export function generateDocumentTypeMarkdown(docTypeResponse: DocumentTypeResponse): string {
    let md = \`\\n## \${docTypeResponse.documentType}\\n\\n\`;
    md += \`\${docTypeResponse.description}\\n\\n\`;

    for (const typeDoc of docTypeResponse.responseIncludes) {
        md += generateTypeMarkdown(typeDoc);
        md += \`\\n\`;
    }

    return md;
}

export function generateFullHelpMarkdown(): string {
    let md = \`# getコマンドのレスポンス形式\\n\\n\`;
    md += \`このコマンドは、書類の種別 (--type) に応じて異なるJSONを返します。\\n\`;
    md += \`以下に各書類種別で返されるJSONのキー、日本語名、型を示します。\\n\\n\`;
    md += \`## 書類種別の指定方法\\n\\n\`;
    md += \`--type オプションには、以下のいずれかの形式で指定できます:\\n\`;
    md += \`- エイリアス名 (例: annual, quarterly, largeshareholding)\\n\`;
    md += \`- 書類種別コード (例: 120, 140, 340)\\n\\n\`;

    for (const docType of DOCUMENT_TYPE_RESPONSES) {
        md += generateDocumentTypeMarkdown(docType);
    }

    return md;
}
`;

    return code;
}

// Main execution
function main() {
    // Configuration: Define which interfaces to extract from which files
    const interfaceConfig = [
        {
            sourceFile: path.join(__dirname, "..", "src", "edinet-xbrl-object.ts"),
            interfaces: ["CommonMetadata", "KeyMetrics", "LargeShareholdingInfo", "QualitativeInfo"]
        },
        {
            sourceFile: path.join(__dirname, "..", "src", "types", "jppfs_cor_taxonomy.ts"),
            interfaces: ["JppfsCorTaxonomy"]
        },
        {
            sourceFile: path.join(__dirname, "..", "src", "types", "jpcrp_cor_taxonomy.ts"),
            interfaces: ["JpcrpCorTaxonomy"]
        }
    ];

    const documentTypeConfig = [
        {
            sourceFile: path.join(__dirname, "..", "src", "edinet-xbrl-object.ts"),
            interfaces: [
                "AnnualResponse",
                "QuarterlyResponse",
                "SemiAnnualResponse",
                "ExtraordinaryResponse",
                "LargeShareholdingResponse",
                "SecuritiesRegistrationResponse",
                "InternalControlResponse",
                "TenderOfferResponse"
            ]
        }
    ];

    const project = new Project();
    const allInterfaces = [];
    const allDocTypes = [];

    // Process regular interfaces
    for (const config of interfaceConfig) {
        const sourceFile = project.addSourceFileAtPath(config.sourceFile);

        for (const interfaceName of config.interfaces) {
            try {
                const interfaceDecl = sourceFile.getInterfaceOrThrow(interfaceName);
                const info = extractInterfaceInfo(interfaceDecl);

                allInterfaces.push(info);
                console.log(`  ✓ Parsed Interface ${interfaceName}: ${info.fields.length} fields`);
            } catch (error) {
                console.error(`\nError: Failed to parse interface '${interfaceName}' from ${config.sourceFile}`);
                console.error(error.message);
                process.exit(1);
            }
        }
    }

    // Process document type response interfaces
    for (const config of documentTypeConfig) {
        const sourceFile = project.addSourceFileAtPath(config.sourceFile);

        for (const interfaceName of config.interfaces) {
            try {
                const interfaceDecl = sourceFile.getInterfaceOrThrow(interfaceName);
                const docInfo = extractDocumentTypeInfo(interfaceDecl);

                if (docInfo) {
                    allDocTypes.push(docInfo);
                    console.log(`  ✓ Parsed DocumentType ${interfaceName}: ${docInfo.documentType}`);
                } else {
                    console.warn(`  ! Skipped DocumentType ${interfaceName}: Missing JSDoc tags`);
                }
            } catch (error) {
                console.error(`\nError: Failed to parse interface '${interfaceName}' from ${config.sourceFile}`);
                console.error(error.message);
                process.exit(1);
            }
        }
    }

    // Generate code
    const outputFilePath = path.join(__dirname, "..", "src", "utils", "type-doc-generator.ts");
    const code = generateTypeDocCode(allInterfaces, allDocTypes);

    // Write output
    fs.writeFileSync(outputFilePath, code, "utf-8");

    console.log(`\n✓ Generated type documentation: ${outputFilePath}`);
    console.log(`  Total interfaces: ${allInterfaces.length}`);
    console.log(`  Total document types: ${allDocTypes.length}`);
}

main();
