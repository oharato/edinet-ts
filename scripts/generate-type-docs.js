#!/usr/bin/env node
/**
 * Auto-generate type documentation from TypeScript source files
 * Extracts interface definitions and JSDoc comments from src/edinet-xbrl-object.ts
 */

const ts = require("typescript");
const fs = require("fs");
const path = require("path");

/**
 * Extract JSDoc comment text from a node
 */
function getJSDocComment(node, sourceFile) {
    const fullText = sourceFile.getFullText();
    const nodeStart = node.getFullStart();
    const ranges = ts.getLeadingCommentRanges(fullText, nodeStart);
    
    if (ranges && ranges.length > 0) {
        const lastRange = ranges[ranges.length - 1];
        const commentText = fullText.substring(lastRange.pos, lastRange.end);
        
        // Extract content from /** ... */
        const match = commentText.match(/\/\*\*([\s\S]*?)\*\//);
        if (match) {
            // Remove leading * and whitespace from each line, filter empty lines
            return match[1]
                .split('\n')
                .map(line => {
                    // Remove leading whitespace and * character
                    const cleaned = line.replace(/^\s*\*\s?/, '').trim();
                    return cleaned;
                })
                .filter(line => line.length > 0)
                .join(' ');
        }
    }
    
    return undefined;
}

/**
 * Get TypeScript type as string
 */
function getTypeString(typeNode) {
    if (!typeNode) return "any";
    
    switch (typeNode.kind) {
        case ts.SyntaxKind.NumberKeyword:
            return "number";
        case ts.SyntaxKind.StringKeyword:
            return "string";
        case ts.SyntaxKind.BooleanKeyword:
            return "boolean";
        case ts.SyntaxKind.UnionType:
            return typeNode.types.map(t => getTypeString(t)).join(" | ");
        default:
            return typeNode.getText();
    }
}

/**
 * Parse interface from source file
 */
function parseInterface(sourceFile, interfaceName) {
    const fields = [];
    
    function visit(node) {
        if (ts.isInterfaceDeclaration(node) && node.name.text === interfaceName) {
            node.members.forEach(member => {
                if (ts.isPropertySignature(member) && member.name) {
                    const key = member.name.getText(sourceFile);
                    const japaneseLabel = getJSDocComment(member, sourceFile) || "";
                    const isOptional = member.questionToken !== undefined;
                    const baseType = getTypeString(member.type);
                    const type = isOptional ? `${baseType} (optional)` : baseType;
                    
                    fields.push({ key, japaneseLabel, type });
                }
            });
        }
        
        ts.forEachChild(node, visit);
    }
    
    visit(sourceFile);
    
    return fields.length > 0 ? { name: interfaceName, fields } : null;
}

/**
 * Generate TypeScript code for type documentation
 */
function generateTypeDocCode(interfaces) {
    let code = `/**
 * Auto-generated type documentation
 * Generated from src/edinet-xbrl-object.ts
 * DO NOT EDIT THIS FILE MANUALLY - Run 'npm run generate-type-docs' to regenerate
 */

export interface FieldInfo {
    key: string;
    japaneseLabel: string;
    type: string;
}

export interface TypeDocumentation {
    typeName: string;
    description: string;
    fields: FieldInfo[];
}

`;

    // Generate constants for each interface
    for (const iface of interfaces) {
        const constName = iface.name.replace(/([A-Z])/g, '_$1').toUpperCase().replace(/^_/, '');
        
        // Map interface names to Japanese descriptions
        const descriptionMap = {
            'KeyMetrics': '財務・業績の主要指標',
            'LargeShareholdingInfo': '大量保有報告書の情報',
            'QualitativeInfo': '定性的情報（テキスト）'
        };
        const description = descriptionMap[iface.name] || iface.name;
        
        code += `export const ${constName}_DOC: TypeDocumentation = {\n`;
        code += `    typeName: "${iface.name}",\n`;
        code += `    description: "${description}",\n`;
        code += `    fields: [\n`;
        
        for (const field of iface.fields) {
            // Escape special characters for TypeScript string literal
            const escapedLabel = field.japaneseLabel
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
            code += `        { key: "${field.key}", japaneseLabel: "${escapedLabel}", type: "${field.type}" },\n`;
        }
        
        code += `    ]\n`;
        code += `};\n\n`;
    }

    // Add common metadata doc
    code += `export const COMMON_METADATA_DOC: TypeDocumentation = {
    typeName: "共通メタデータ",
    description: "全ての書類に含まれるメタデータ",
    fields: [
        { key: "docID", japaneseLabel: "書類管理ID", type: "string" },
        { key: "filerName", japaneseLabel: "提出者名", type: "string" },
        { key: "edinetCode", japaneseLabel: "提出者のEDINETコード", type: "string" },
        { key: "docDescription", japaneseLabel: "書類名/件名", type: "string" },
        { key: "submitDate", japaneseLabel: "提出日", type: "string" }
    ]
};

`;

    // Add document type responses
    code += `export interface DocumentTypeResponse {
    documentType: string;
    japaneseLabel: string;
    description: string;
    responseIncludes: TypeDocumentation[];
}

export const DOCUMENT_TYPE_RESPONSES: DocumentTypeResponse[] = [
    {
        documentType: "Annual (有価証券報告書) [120]",
        japaneseLabel: "有価証券報告書",
        description: "年次の有価証券報告書。財務情報を含みます。",
        responseIncludes: [COMMON_METADATA_DOC, KEY_METRICS_DOC]
    },
    {
        documentType: "Quarterly (四半期報告書) [140]",
        japaneseLabel: "四半期報告書",
        description: "四半期ごとの報告書。財務情報を含みます。",
        responseIncludes: [COMMON_METADATA_DOC, KEY_METRICS_DOC]
    },
    {
        documentType: "SemiAnnual (半期報告書) [160]",
        japaneseLabel: "半期報告書",
        description: "半期ごとの報告書。財務情報を含みます。",
        responseIncludes: [COMMON_METADATA_DOC, KEY_METRICS_DOC]
    },
    {
        documentType: "Extraordinary (臨時報告書) [180]",
        japaneseLabel: "臨時報告書",
        description: "臨時報告書。財務情報を含む場合があります。",
        responseIncludes: [COMMON_METADATA_DOC, KEY_METRICS_DOC]
    },
    {
        documentType: "LargeShareholding (大量保有報告書) [340/350/360]",
        japaneseLabel: "大量保有報告書",
        description: "大量保有報告書、変更報告書、訂正報告書。保有情報を含みます。",
        responseIncludes: [COMMON_METADATA_DOC, LARGE_SHAREHOLDING_INFO_DOC]
    },
    {
        documentType: "SecuritiesRegistration (有価証券届出書) [010]",
        japaneseLabel: "有価証券届出書",
        description: "有価証券届出書。財務情報を含む場合があります。",
        responseIncludes: [COMMON_METADATA_DOC, KEY_METRICS_DOC]
    },
    {
        documentType: "InternalControl (内部統制報告書) [235]",
        japaneseLabel: "内部統制報告書",
        description: "内部統制報告書。主にメタデータのみが返されます。",
        responseIncludes: [COMMON_METADATA_DOC]
    },
    {
        documentType: "TenderOffer (公開買付届出書/報告書) [240/270]",
        japaneseLabel: "公開買付関連書類",
        description: "公開買付届出書または公開買付報告書。主にメタデータのみが返されます。",
        responseIncludes: [COMMON_METADATA_DOC]
    }
];

export function generateTypeMarkdown(doc: TypeDocumentation): string {
    let md = \`### \${doc.typeName}\\n\\n\`;
    md += \`\${doc.description}\\n\\n\`;
    md += \`| キー | 日本語名 | 型 |\\n\`;
    md += \`| --- | --- | --- |\\n\`;
    
    for (const field of doc.fields) {
        md += \`| \\\`\${field.key}\\\` | \${field.japaneseLabel} | \\\`\${field.type}\\\` |\\n\`;
    }
    
    return md;
}

export function generateDocumentTypeMarkdown(docTypeResponse: DocumentTypeResponse): string {
    let md = \`\\n## \${docTypeResponse.documentType}\\n\\n\`;
    md += \`\${docTypeResponse.description}\\n\\n\`;
    
    for (const typeDoc of docTypeResponse.responseIncludes) {
        md += generateTypeMarkdown(typeDoc);
        md += \`\\n\`;
    }
    
    return md;
}

export function generateFullHelpMarkdown(): string {
    let md = \`# getコマンドのレスポンス形式\\n\\n\`;
    md += \`このコマンドは、書類の種別 (--type) に応じて異なるJSONを返します。\\n\`;
    md += \`以下に各書類種別で返されるJSONのキー、日本語名、型を示します。\\n\\n\`;
    md += \`## 書類種別の指定方法\\n\\n\`;
    md += \`--type オプションには、以下のいずれかの形式で指定できます:\\n\`;
    md += \`- エイリアス名 (例: annual, quarterly, largeshareholding)\\n\`;
    md += \`- 書類種別コード (例: 120, 140, 340)\\n\\n\`;
    
    for (const docType of DOCUMENT_TYPE_RESPONSES) {
        md += generateDocumentTypeMarkdown(docType);
    }
    
    return md;
}
`;

    return code;
}

// Main execution
function main() {
    // Configuration: Define which interfaces to extract from which files
    const interfaceConfig = [
        {
            sourceFile: path.join(__dirname, "..", "src", "edinet-xbrl-object.ts"),
            interfaces: ["KeyMetrics", "LargeShareholdingInfo", "QualitativeInfo"]
        }
    ];
    
    const allInterfaces = [];
    
    // Process each source file
    for (const config of interfaceConfig) {
        const sourceCode = fs.readFileSync(config.sourceFile, "utf-8");
        const sourceFile = ts.createSourceFile(
            config.sourceFile,
            sourceCode,
            ts.ScriptTarget.Latest,
            true
        );
        
        // Parse each interface
        for (const interfaceName of config.interfaces) {
            const parsedInterface = parseInterface(sourceFile, interfaceName);
            if (!parsedInterface) {
                console.error(`\nError: Failed to parse interface '${interfaceName}' from ${config.sourceFile}`);
                console.error(`Possible causes:`);
                console.error(`  - Interface '${interfaceName}' does not exist in the file`);
                console.error(`  - Interface has no fields or properties`);
                console.error(`  - Syntax error in the interface definition`);
                console.error(`\nPlease verify the interface name and definition.`);
                process.exit(1);
            }
            allInterfaces.push(parsedInterface);
            console.log(`  ✓ Parsed ${interfaceName}: ${parsedInterface.fields.length} fields`);
        }
    }
    
    // Generate code
    const outputFilePath = path.join(__dirname, "..", "src", "utils", "type-doc-generator.ts");
    const code = generateTypeDocCode(allInterfaces);
    
    // Write output
    fs.writeFileSync(outputFilePath, code, "utf-8");
    
    console.log(`\n✓ Generated type documentation: ${outputFilePath}`);
    console.log(`  Total interfaces: ${allInterfaces.length}`);
}

main();
